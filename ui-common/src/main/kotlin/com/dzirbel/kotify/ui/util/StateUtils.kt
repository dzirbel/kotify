package com.dzirbel.kotify.ui.util

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.ProduceStateScope
import androidx.compose.runtime.State
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext

/**
 * Convenience function to produce a derived [State] by applying [transform] to the value of [State].
 */
@Composable
fun <T, R> State<T>.derived(transform: (T) -> R): State<R> {
    return remember(this) { derivedStateOf { transform(this.value) } }
}

@Composable
fun <T> StateFlow<T>.collectAsStateSwitchable(key: Any?, context: CoroutineContext = Dispatchers.IO): State<T> {
    return collectAsStateSwitchable(initial = { value }, key = key, context = context)
}

/**
 * Collects values from this [Flow] and represents its latest value via [State].
 *
 * Unlike [collectAsState], this function is capable of switching between different input [Flow]s via [key]; that is, if
 * [key] ever changes, the [initial] value will be fetched again and used. [collectAsState] does not change its state
 * when the underlying [Flow] changes, only when it emits new values.
 */
@Composable
fun <T> Flow<T>.collectAsStateSwitchable(
    initial: () -> T,
    key: Any?,
    context: CoroutineContext = Dispatchers.IO,
): State<T> {
    // copied from internal compose code
    class ProduceStateScopeImpl<T>(state: MutableState<T>, override val coroutineContext: CoroutineContext) :
        ProduceStateScope<T>, MutableState<T> by state {

        override suspend fun awaitDispose(onDispose: () -> Unit): Nothing {
            try {
                suspendCancellableCoroutine<Nothing> { }
            } finally {
                onDispose()
            }
        }
    }

    val result = remember(key) { mutableStateOf(initial()) }
    LaunchedEffect(this, context, key) {
        ProduceStateScopeImpl(result, coroutineContext).run {
            if (context == EmptyCoroutineContext) {
                collect { value = it }
            } else {
                withContext(context) {
                    collect { value = it }
                }
            }
        }
    }
    return result
}

/**
 * Returns a [State] which reflects the first non-null value produced by this [StateFlow].
 *
 * This avoids collecting the [StateFlow] indefinitely (unless it never emits a non-null value), or even collecting it
 * at all if the initial value is non-null.
 */
@Composable
fun <T : Any> StateFlow<T?>.firstAsState(): State<T?> {
    val initialValue = remember(this) { value }
    return if (initialValue == null) {
        produceState<T?>(initialValue = null, key1 = this) {
            value = firstOrNull { it != null }
        }
    } else {
        remember(this) { mutableStateOf(initialValue) }
    }
}

/**
 * Returns the value iteratively generated by [generate], which returns the next value to expose and a delay in
 * milliseconds before it should be called to generate the next value.
 */
@Composable
fun <T> iterativeState(key: Any? = null, generate: () -> Pair<T, Long>): T {
    val (initialValue, initialDelay) = remember(key) { generate() }

    return produceState(initialValue = initialValue, key1 = key) {
        delay(initialDelay)
        while (true) {
            val (result, delay) = generate()

            value = result

            delay(delay)
        }
    }.value
}
